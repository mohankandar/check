package gov.va.bip.framework.log;

import gov.va.bip.framework.shared.sanitize.Sanitizer;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.slf4j.Marker;
import org.slf4j.event.Level;

import com.fasterxml.jackson.core.io.JsonStringEncoder;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * Base logger class that:
 * <li>splits messages so large messages can be logged in spite of the docker 16 KB limit
 * <li>can print ASCII Art banner messages in the log
 * <p>
 *
 * @author aburkholder
 */
public class VipBaseLogger {

    /** Maximum length allowed for a single log entry, as dictated by Docker limits */
    public static final int MAX_TOTAL_LOG_LEN = 16384;

    /** The string to prepend when a message must be split */
    private static final String SPLIT_MDC_NAME = "Split-Log-Sequence";

    /** The actual logger implementation (logback under slf4j) */
    private org.slf4j.Logger logger;

    /** The space character */
    protected static final String SPACE = " ";

    /** Systems line separator */
    protected static final String NEWLINE = System.lineSeparator();

    /** Name of the root logger */
    public static final String ROOT_LOGGER_NAME = org.slf4j.Logger.ROOT_LOGGER_NAME;

    /** Maximum length reserved for MDC and JSON formatting */
    public static final int MDC_RESERVE_LENGTH = 10240;

    /** Maximum length reserved for the stack trace part of the log */
    public static final int MAX_STACK_TRACE_TEXT_LENGTH = 6144;

    /**
     * Create a new logger for apps.
     *
     * @param logger org.slf4j.Logger
     */
    protected BipBaseLogger(final org.slf4j.Logger logger) {
        if (logger == null) {
            throw new IllegalArgumentException("Logger cannot be null");
        }
        this.logger = logger;
    }

    /**
     * Set the log level for the logger to a new logging level.
     * <p>
     * This method accesses the underlying log implementation (e.g., logback).
     *
     * @param level the org.slf4j.event.Level
     */
    public void setLevel(final Level level) {
        ((ch.qos.logback.classic.Logger) logger).setLevel(ch.qos.logback.classic.Level.toLevel(level.name()));
    }

    /**
     * Get the current log level for the logger.
     * If no level has been set, the ROOT_LOGGER level is returned.
     * If ROOT_LOGGER has not been set, INFO is returned.
     * <p>
     * This method accesses the underlying log implementation (e.g., logback).
     *
     * @return Level the org.slf4j.event.Level
     */
    public Level getLevel() {
        ch.qos.logback.classic.Level lvl = ((ch.qos.logback.classic.Logger) logger).getLevel();
        if (lvl == null) {
            lvl = ((ch.qos.logback.classic.Logger) LoggerFactory.getILoggerFactory().getLogger(ROOT_LOGGER_NAME)).getLevel();
        }
        return lvl == null ? Level.INFO : Level.valueOf(lvl.toString());
    }

    /**
     * Get the underlying logger interface implementation (in this case, slf4j).
     *
     * @return Logger
     */
    protected org.slf4j.Logger getLoggerInterfaceImpl() {
        return this.logger;
    }

    /* ================ Logger ================ */

    /**
     * Generic logging, allowing to specify the log level, and optional marker.
     *
     * @param level the log level
     * @param marker the marker (or null)
     * @param message the message to log
     */
    protected void sendLog(final Level level, final Marker marker, final String message, final Throwable t) {
        String stackTrace = getStackTraceAsString(t);
        String logMessage = safeMessage(message) + (stackTrace.length() > 0 ? NEWLINE + NEWLINE + stackTrace : "");
        Level levelToLogAt = (level == null) ? this.getLevel() : level;
        this.sendLogAtLevel(levelToLogAt, marker, logMessage, t);
    }

    /**
     * Splits a string into a list of strings, each entry of which does not exceed
     * the specified maxLengthPerString.
     * <p>
     * Each entry on the returned list will be comprised of whole words.
     *
     * @param string the string to split
     * @return List of strings, each of which does not exceed maxLengthPerString
     */
    private List<String> splitStringToLength(final String string, final int maxLengthPerString) {
        if (maxLengthPerString < 1) {
            throw new IllegalArgumentException("maxLengthPerString must be greater than zero.");
        }
        if (string == null) {
            return Collections.singletonList("");
        }

        List<String> resultList = new ArrayList<>();
        StringBuilder currentString = new StringBuilder();
        for (String word : string.split(SPACE)) {
            if (currentString.length() + word.length() + 1 > maxLengthPerString) {
                resultList.add(currentString.toString().trim());
                currentString.setLength(0);
            }
            currentString.append(word).append(SPACE);
        }
        if (currentString.length() > 0) {
            resultList.add(currentString.toString().trim());
        }
        return resultList;
    }

    /**
     * Logs each string in the strings list, using the marker and level supplied.
     * <p>
     * If there is more than one entry in the strings list, the MDC includes an entry with
     * SPLIT_MDC_NAME and the sequential '# of #' string.
     *
     * @param strings the list of strings to be logged
     * @param marker any marker (or null)
     * @param level the log level, if null, the current logger's log level is used
     */
    private void logStrings(final List<String> strings, final Marker marker, final Level level) {
        List<String> stringsToLog = (strings == null || strings.isEmpty())
                ? Collections.singletonList("No log message provided. This log entry records the empty log event.")
                : strings;
        Level levelToLogAt = (level == null) ? this.getLevel() : level;

        if (stringsToLog.size() < 2) {
            this.sendLogAtLevel(levelToLogAt, marker, stringsToLog.get(0), null);
            return;
        }

        String maxSequence = Integer.toString(stringsToLog.size());
        int sequence = 1;
        for (String toLog : stringsToLog) {
            MDC.put(SPLIT_MDC_NAME, sequence++ + " of " + maxSequence);
            this.sendLogAtLevel(levelToLogAt, marker, toLog, null);
            MDC.remove(SPLIT_MDC_NAME);
        }
    }

    /**
     * Get the stack trace formatted the same way as with Throwable.printStackTrace().
     *
     * @param t Throwable that contains the stack trace
     * @return String the formatted stack trace
     */
    private String getStackTraceAsString(final Throwable t) {
        if (t == null) {
            return "";
        }

        StringWriter writer = new StringWriter();
        PrintWriter printWriter = new PrintWriter(writer);
        t.printStackTrace(printWriter);
        printWriter.flush();
        return writer.toString();
    }

    /**
     * Get a string that is stripped of XSS characters,
     * and is safe for use within a JSON context - escapes quotes, etc.
     * <p>
     * If {@code null} is passed as the message, then empty string ({@code ""}) will be returned.
     *
     * @param message the message to sanitize
     * @return String the escaped message, or {@code ""} if the message is null
     */
    private String safeMessage(final String message) {
        return message == null ? "" : JsonStringEncoder.getInstance()
                .quoteAsString(Sanitizer.stripXss(message));
    }

    /**
     * Perform genericized logging for a given log level.
     * <p>
     * If log level is {@code null}, DEBUG is assumed.
     *
     * @param level the log level
     * @param marker the marker (or null)
     * @param message the message to log
     * @param t the Throwable, if needed
     */
    private void sendLogAtLevel(final Level level, final Marker marker, final String message, final Throwable t) {
        if (level == null) {
            sendLogDebug(marker, message, t);
        } else {
            switch (level) {
                case ERROR:
                    sendLogError(marker, message, t);
                    break;
                case WARN:
                    sendLogWarn(marker, message, t);
                    break;
                case INFO:
                    sendLogInfo(marker, message, t);
                    break;
                case TRACE:
                    sendLogTrace(marker, message, t);
                    break;
                default:
                    sendLogDebug(marker, message, t);
            }
        }
    }

    /**
     * Separate logger method for TRACE log levels.
     *
     * @param marker the marker (or null)
     * @param message the message to log
     * @param t the Throwable, if needed
     */
    private void sendLogTrace(final Marker marker, final String message, final Throwable t) {
        if (logger.isTraceEnabled()) {
            logger.trace(marker, message, t);
        }
    }

    /**
     * Separate logger method for DEBUG log levels.
     *
     * @param marker the marker (or null)
     * @param message the message to log
     * @param t the Throwable, if needed
     */
    private void sendLogDebug(final Marker marker, final String message, final Throwable t) {
        if (logger.isDebugEnabled()) {
            logger.debug(marker, message, t);
        }
    }

    /**
     * Separate logger method for INFO log levels.
     *
     * @param marker the marker (or null)
     * @param message the message to log
     * @param t the Throwable, if needed
     */
    private void sendLogInfo(final Marker marker, final String message, final Throwable t) {
        if (logger.isInfoEnabled()) {
            logger.info(marker, message, t);
        }
    }

    /**
     * Separate logger method for WARN log levels.
     *
     * @param marker the marker (or null)
     * @param message the message to log
     * @param t the Throwable, if needed
     */
    private void sendLogWarn(final Marker marker, final String message, final Throwable t) {
        if (logger.isWarnEnabled()) {
            logger.warn(marker, message, t);
        }
    }

    /**
     * Separate logger method for ERROR log levels.
     *
     * @param marker the marker (or null)
     * @param message the message to log
     * @param t the Throwable, if needed
     */
    private void sendLogError(final Marker marker, final String message, final Throwable t) {
        if (logger.isErrorEnabled()) {
            logger.error(marker, message, t);
        }
    }
}
